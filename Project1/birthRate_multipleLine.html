<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <title>US Birth Rate for females by age group(1940-2015)</title>
</head>
<style> /* set the CSS */

body { font: 12px Arial;}

path {
    stroke: blue;
    stroke-width: 2;
    fill: none;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

.legend {
    font-size: 14px;
    font-weight: bold;
    text-anchor: middle;
}

.line {
    fill: none;
    stroke: steelblue;
    stroke-width: 1.5px;
}

.zoom{
    cursor:move;
    fill:none;
    pointer-events: all;
}

.brush .extent {
    stroke: #fff;
    fill-opacity: .125;
    shape-rendering: crispEdges;
}

div.tooltip {
    position: absolute;
    text-align: center;
    padding: 5px;
    font: 12px sans-serif;
    background: black;
    color: white;
    border: 1px;
    border-radius: 4px;
    pointer-events: none;
}

button{
    position: relative;
    left: 310px;
}


</style>
<body>

<div id="option">
    <input name="updateButton" type="button" value="Select/Clear all" />
</div>


    <!-- load the d3.js library -->
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

    // Set the dimensions of the canvas / graph
    const margin = {top: 80, right: 90, bottom: 150, left: 80},
        width = 900 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom;

    // Set the dimensions of zoom area
    const marginZoom = {top:500, right:90, bottom:30,left:80},
        heightZoom = 600 - marginZoom.top - marginZoom.bottom;

    // Add the svg canvas to the body of the page
    const svg = d3.select("body")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);
        // .append("g")
        // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // clip path
    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);
    // .attr("x", 0)
    // .attr("y", 0);


    // Parse the date / time
    var parse = d3.time.format("%Y").parse;

    // Set the ranges
    const x = d3.time.scale().range([0, width]);
    const y = d3.scale.linear().range([height-20, 0]);
    const color = d3.scale.category10();
    // Set the ranges of zoomed x and y
    const xZoom = d3.time.scale().range([0, width]);
    const yZoom = d3.scale.linear().range([heightZoom -10, 0]);

    // Define the axes
    const xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(6);
    const yAxis = d3.svg.axis().scale(y).orient("left").ticks(8);
    // Define zoomed x axes
    const xAxisZoom = d3.svg.axis().scale(xZoom).orient("bottom").ticks(6);

    // Brush function
    var brush = d3.svg.brush()
        .x(xZoom)
        .on("brush", brush);

    // Define the line
    const valueline = d3.svg.line()
        // .interpolate("basis")
        .defined(function(d) { return !isNaN(d.birthRate); })
        .interpolate("cubic")
        .x(function(d) { return x(d.date); })
        .y(function(d) { return y(d.birthRate); });

    // Define zoomed line
    const valuelineZoom = d3.svg.line()
        .defined(function(d) { return !isNaN(d.birthRate); })
        .interpolate("cubic")
        .x(function(d){return xZoom(d.date)})
        .y(function(d){return yZoom(d.birthRate)});



    var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // add zoomed area
    var context = svg.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + marginZoom.left + "," + marginZoom.top + ")");

    // var div = d3.select("body").append("div")
    //     .attr("class", "tooltip")
    //     .style("opacity", 0);

    // get the data
    d3.csv("birthRate.csv", function(error, data) {
        data.forEach(function (d) {
            d.date = parse(d.year);
            d.birthRate = +d.birthRate;
        });

        data.sort(function (a, b) {
            if (a.date < b.date)
                return -1;
            else if (a.dater > b.date)
                return 1;
            else
                return 0;
        })


        // group the entries by age groups
        let newData = d3.nest().key(item => item.age).entries(data);

        // Domain of the data
        x.domain(d3.extent(data, function (d) {
            return d.date;
        }));
        y.domain([0, d3.max(data, function (d) {
            return d.birthRate;
        })]).nice();

        //
        // y.domain([d3.min(newData, function(c) { return d3.min(c.values, function(v) { return v.birthRate; }); }),
        //     d3.max(newData, function(c) { return d3.max(c.values, function(v) { return v.birthRate; }); }) ]);

        //Domain of the zoomed data
        xZoom.domain(x.domain());
        yZoom.domain(y.domain());

        focus.selectAll(".line").remove();
        context.selectAll(".line").remove();



       // loop through each age/key
       //  newData.forEach(function (d, i) {
       //      svg.append("path")
       //          .attr("class", "line")
       //          .style("stroke", function () {
       //              return d.color = color(d.key);
       //          })
       //          .attr("id", 'tag' + d.key.replace(/\s+/g, '')) // assign ID **
       //          .attr("d", valueline(d.values));
       //  })


        // draw main graph
        focus.selectAll("line").data(newData).enter().append("path")
            .attr("class", "line")
            .attr("d", function (d) {
                return valueline(d.values)
            })
            .style("stroke", function (d) {
                return d.color = color(d.key);

            })
            .attr("id", function(d){return 'tag' + d.key.replace(/\s+/g, '')}) // assign ID **
            .attr("clip-path", "url(#clip)");

        focus.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        focus.append("g")
            .attr("class", "y axis")
            .call(yAxis);

        context.selectAll(".line").data(newData).enter().append("path")
            .attr("class", "line")
            .attr("d", function (d) {
                return valuelineZoom(d.values)
            })
            .style("stroke", function (d) {
                return d.color = color(d.key);
            })
            .attr("id", function(d){return 'tag1' + d.key.replace(/\s+/g, '')})
            .attr("clip-path", "url(#clip)");

        context.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + heightZoom + ")")
            .call(xAxisZoom);

        context.append("g")
            .attr("class", "x brush")
            .call(brush)
            .selectAll("rect")
            .attr("y", -6)
            .attr("height", heightZoom + 7  );



        //spacing for the legend
        // legendSpace = width / newData.length;
        const legendSpace = (height+margin.top) / newData.length;

            // add the legend
        newData.forEach(function(d, i) {
            svg.append("text")
                .attr("x", width + margin.right + margin.left/ 2)
                // .attr("x", (legengendSpace / 2) + i * legendSpace) // spacing
                // .attr("y", (height + (margin.bottom / 2) + 15)
                .attr("y", (legendSpace / 2) + i * legendSpace)
                .attr("class", "legend")    // style the legend
                .style("fill", function () { // dynamic colors
                    return d.color = color(d.key);
                })
                .on("click", function () {
                    // Determine if current line is visible
                    var active = d.active ? false : true,
                        newOpacity = active ? 0 : 1;
                    // Hide or show the elements based on the ID
                    d3.select("#tag" + d.key.replace(/\s+/g, ''))
                        .transition().duration(100)
                        .style("opacity", newOpacity);
                    d3.select("#tag1" + d.key.replace(/\s+/g, ''))
                        .transition().duration(100)
                        .style("opacity", newOpacity);
                    // Update whether or not the elements are active
                    d.active = active;
                })
                .text(d.key);

        })
//==================== tooltips ============================

        // var mouseG = svg.append("g")
        //     .attr("class", "mouse-over-effects");
        //
        // mouseG.append("path") // this is the black vertical line to follow mouse
        //     .attr("class", "mouse-line")
        //     .style("stroke", "black")
        //     .style("stroke-width", "1px")
        //     .style("opacity", "0");
        //
        // var lines = document.getElementsByClassName('line');
        //
        // var mousePerLine = mouseG.selectAll('.mouse-per-line')
        //     .data(newData)
        //     .enter()
        //     .append("g")
        //     .attr("class", "mouse-per-line");
        //
        // mousePerLine.append("circle")
        //     .attr("r", 7)
        //     .style("stroke", function (d) {
        //         return color(d.key);
        //     })
        //     .style("fill", "none")
        //     .style("stroke-width", "1px")
        //     .style("opacity", "0");
        //
        // mousePerLine.append("text")
        //     .attr("transform", "translate(10,3)");
        //
        // mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
        //     .attr('width', width) // can't catch mouse events on a g element
        //     .attr('height', height)
        //     .attr('fill', 'none')
        //     .attr('pointer-events', 'all')
        //     .on('mouseout', function () { // on mouse out hide line, circles and text
        //         d3.select(".mouse-line")
        //             .style("opacity", "0");
        //         d3.selectAll(".mouse-per-line circle")
        //             .style("opacity", "0");
        //         d3.selectAll(".mouse-per-line text")
        //             .style("opacity", "0");
        //     })
        //     .on('mouseover', function () { // on mouse in show line, circles and text
        //         d3.select(".mouse-line")
        //             .style("opacity", "1");
        //         d3.selectAll(".mouse-per-line circle")
        //             .style("opacity", "1");
        //         d3.selectAll(".mouse-per-line text")
        //             .style("opacity", "1");
        //     })
        //     .on('mousemove', function () { // mouse moving over canvas
        //         var mouse = d3.mouse(this);
        //         d3.select(".mouse-line")
        //             .attr("d", function () {
        //                 var d = "M" + mouse[0] + "," + height;
        //                 d += " " + mouse[0] + "," + 0;
        //                 return d;
        //             });
        //
        //         d3.selectAll(".mouse-per-line")
        //             .attr("transform", function (d, i) {
        //                 console.log(width / mouse[0])
        //                 var xDate = x.invert(mouse[0]),
        //                     bisect = d3.bisector(function (d) {
        //                         return d.date;
        //                     }).right;
        //                 idx = bisect(d.values, xDate);
        //
        //                 var beginning = 0,
        //                     end = lines[i].getTotalLength(),
        //                     target = null;
        //
        //                 while (true) {
        //                     target = Math.floor((beginning + end) / 2);
        //                     pos = lines[i].getPointAtLength(target);
        //                     if ((target === end || target === beginning) && pos.x !== mouse[0]) {
        //                         break;
        //                     }
        //                     if (pos.x > mouse[0]) end = target;
        //                     else if (pos.x < mouse[0]) beginning = target;
        //                     else break; //position found
        //                 }
        //
        //                 d3.select(this).select('text')
        //                     .text(y.invert(pos.y).toFixed(2));
        //
        //                 return "translate(" + mouse[0] + "," + pos.y + ")";
        //             });
//======================== Draw circles==================================

                // svg.selectAll("circle")
                //     .data(data).enter()
                //     .append("circle")
                //     .attr("stroke", "#000")
                //     .attr("fill", function(d,i){
                //         if (d.birthRate<50)
                //             return "#0f0";
                //         else if (d.birthRate>=50 && d.birthRate<80)
                //             return "#ff0";
                //         else
                //             return "#f00";
                //     })
                //     .attr("cx", function(d){
                //         return x(d.date);
                //     })
                //     .attr("cy", function(d){
                //         return y(d.birthRate);
                //     })
                //     .attr("r", function(d){
                //         return Math.pow(d.birthRate, 0.05);
                //     });


                // draw the title of the chart
                svg.append("text")
                    .attr("x", (width / 2))
                    .attr("y", (margin.top / 2))
                    .attr("text-anchor", "middle")
                    .style("font-size", "20px")
                    // .style("text-decoration","underline")
                    .text("Birth Rate for Females by Age Group: United States");

                // label for x axis
                svg.append("text")
                    .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.top + 30) + ")")
                    .style("text-anchor", "middle")
                    .text("Year");

                // label for y axis
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", margin.left - 50)
                    .attr("x", 0 - ((height+ heightZoom) / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text("Birth rate per 1000 females in different age groups");

                // // Add x axis
                // svg.append("g")
                //     .attr("class", "x axis")
                //     .attr("transform", "translate(0," + height + ")")
                //     .call(xAxis);
                //
                // // .selectAll("text")
                // // .style("text-anchor","end")
                // // .attr("dx", "-.8em")
                // // .attr("dy", ".15em")
                // // .attr("transform", "rotate(-65)");
                //
                // // Add  y axis
                // svg.append("g")
                //     .attr("class", "y axis")
                //     .call(yAxis);



  // debugger;
                // select/clear all the lines
                var toggle = true;
                d3.select("input")
                    .on("click", function() {
                    d3.selectAll("path.line")
                        .style("opacity", +(toggle = !toggle))
                })


            // });
    // });


});

    function brush() {
        x.domain(brush.empty() ? xZoom.domain() : brush.extent());
        focus.selectAll("path.line")
            .attr("d",  function(d) {return valueline(d.values)});
        focus.select(".x.axis").call(xAxis);
        focus.select(".y.axis").call(yAxis);
    }





</script>
</body>
